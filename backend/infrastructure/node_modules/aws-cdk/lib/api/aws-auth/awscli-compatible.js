"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AwsCliCompatible = void 0;
const credential_providers_1 = require("@aws-sdk/credential-providers");
const ec2_metadata_service_1 = require("@aws-sdk/ec2-metadata-service");
const shared_ini_file_loader_1 = require("@smithy/shared-ini-file-loader");
const promptly = require("promptly");
const proxy_agent_1 = require("proxy-agent");
const provider_caching_1 = require("./provider-caching");
const util_1 = require("./util");
const logging_1 = require("../../logging");
const DEFAULT_CONNECTION_TIMEOUT = 10000;
const DEFAULT_TIMEOUT = 300000;
/**
 * Behaviors to match AWS CLI
 *
 * See these links:
 *
 * https://docs.aws.amazon.com/cli/latest/topic/config-vars.html
 * https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html
 */
class AwsCliCompatible {
    /**
     * Build an AWS CLI-compatible credential chain provider
     *
     * The credential chain returned by this function is always caching.
     */
    static async credentialChainBuilder(options = {}) {
        const clientConfig = {
            requestHandler: AwsCliCompatible.requestHandlerBuilder(options.httpOptions),
            customUserAgent: 'aws-cdk',
            logger: options.logger,
        };
        /**
         * The previous implementation matched AWS CLI behavior:
         *
         * If a profile is explicitly set using `--profile`,
         * we use that to the exclusion of everything else.
         *
         * Note: this does not apply to AWS_PROFILE,
         * environment credentials still take precedence over AWS_PROFILE
         */
        if (options.profile) {
            return (0, provider_caching_1.makeCachingProvider)((0, credential_providers_1.fromIni)({
                profile: options.profile,
                ignoreCache: true,
                mfaCodeProvider: tokenCodeFn,
                clientConfig,
                logger: options.logger,
            }));
        }
        const envProfile = process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE;
        /**
         * Env AWS - EnvironmentCredentials with string AWS
         * Env Amazon - EnvironmentCredentials with string AMAZON
         * Profile Credentials - PatchedSharedIniFileCredentials with implicit profile, credentials file, http options, and token fn
         *    SSO with implicit profile only
         *    SharedIniFileCredentials with implicit profile and preferStaticCredentials true (profile with source_profile)
         *    Shared Credential file that points to Environment Credentials with AWS prefix
         *    Shared Credential file that points to EC2 Metadata
         *    Shared Credential file that points to ECS Credentials
         * SSO Credentials - SsoCredentials with implicit profile and http options
         * ProcessCredentials with implicit profile
         * ECS Credentials - ECSCredentials with no input OR Web Identity - TokenFileWebIdentityCredentials with no input OR EC2 Metadata - EC2MetadataCredentials with no input
         *
         * These translate to:
         * fromEnv()
         * fromSSO()/fromIni()
         * fromProcess()
         * fromContainerMetadata()
         * fromTokenFile()
         * fromInstanceMetadata()
         *
         * The NodeProviderChain is already cached.
         */
        const nodeProviderChain = (0, credential_providers_1.fromNodeProviderChain)({
            profile: envProfile,
            clientConfig,
            logger: options.logger,
            mfaCodeProvider: tokenCodeFn,
            ignoreCache: true,
        });
        return shouldPrioritizeEnv()
            ? (0, credential_providers_1.createCredentialChain)((0, credential_providers_1.fromEnv)(), nodeProviderChain).expireAfter(60 * 60000)
            : nodeProviderChain;
    }
    static requestHandlerBuilder(options = {}) {
        // Force it to use the proxy provided through the command line.
        // Otherwise, let the ProxyAgent auto-detect the proxy using environment variables.
        const getProxyForUrl = options.proxyAddress != null
            ? () => Promise.resolve(options.proxyAddress)
            : undefined;
        const agent = new proxy_agent_1.ProxyAgent({
            ca: tryGetCACert(options.caBundlePath),
            getProxyForUrl: getProxyForUrl,
        });
        return {
            connectionTimeout: DEFAULT_CONNECTION_TIMEOUT,
            requestTimeout: DEFAULT_TIMEOUT,
            httpsAgent: agent,
            httpAgent: agent,
        };
    }
    /**
     * Attempts to get the region from a number of sources and falls back to us-east-1 if no region can be found,
     * as is done in the AWS CLI.
     *
     * The order of priority is the following:
     *
     * 1. Environment variables specifying region, with both an AWS prefix and AMAZON prefix
     *    to maintain backwards compatibility, and without `DEFAULT` in the name because
     *    Lambda and CodeBuild set the $AWS_REGION variable.
     * 2. Regions listed in the Shared Ini Files - First checking for the profile provided
     *    and then checking for the default profile.
     * 3. IMDS instance identity region from the Metadata Service.
     * 4. us-east-1
     */
    static async region(maybeProfile) {
        const defaultRegion = 'us-east-1';
        const profile = maybeProfile || process.env.AWS_PROFILE || process.env.AWS_DEFAULT_PROFILE || 'default';
        const region = process.env.AWS_REGION ||
            process.env.AMAZON_REGION ||
            process.env.AWS_DEFAULT_REGION ||
            process.env.AMAZON_DEFAULT_REGION ||
            (await getRegionFromIni(profile)) ||
            (await regionFromMetadataService());
        if (!region) {
            const usedProfile = !profile ? '' : ` (profile: "${profile}")`;
            (0, logging_1.debug)(`Unable to determine AWS region from environment or AWS configuration${usedProfile}, defaulting to '${defaultRegion}'`);
            return defaultRegion;
        }
        return region;
    }
}
exports.AwsCliCompatible = AwsCliCompatible;
/**
 * Looks up the region of the provided profile. If no region is present,
 * it will attempt to lookup the default region.
 * @param profile The profile to use to lookup the region
 * @returns The region for the profile or default profile, if present. Otherwise returns undefined.
 */
async function getRegionFromIni(profile) {
    const sharedFiles = await (0, shared_ini_file_loader_1.loadSharedConfigFiles)({ ignoreCache: true });
    // Priority:
    //
    // credentials come before config because aws-cli v1 behaves like that.
    //
    // 1. profile-region-in-credentials
    // 2. profile-region-in-config
    // 3. default-region-in-credentials
    // 4. default-region-in-config
    return getRegionFromIniFile(profile, sharedFiles.credentialsFile)
        ?? getRegionFromIniFile(profile, sharedFiles.configFile)
        ?? getRegionFromIniFile('default', sharedFiles.credentialsFile)
        ?? getRegionFromIniFile('default', sharedFiles.configFile);
}
function getRegionFromIniFile(profile, data) {
    return data?.[profile]?.region;
}
function tryGetCACert(bundlePath) {
    const path = bundlePath || caBundlePathFromEnvironment();
    if (path) {
        (0, logging_1.debug)('Using CA bundle path: %s', path);
        return (0, util_1.readIfPossible)(path);
    }
    return undefined;
}
/**
 * Find and return a CA certificate bundle path to be passed into the SDK.
 */
function caBundlePathFromEnvironment() {
    if (process.env.aws_ca_bundle) {
        return process.env.aws_ca_bundle;
    }
    if (process.env.AWS_CA_BUNDLE) {
        return process.env.AWS_CA_BUNDLE;
    }
    return undefined;
}
/**
 * We used to support both AWS and AMAZON prefixes for these environment variables.
 *
 * Adding this for backward compatibility.
 */
function shouldPrioritizeEnv() {
    const id = process.env.AWS_ACCESS_KEY_ID || process.env.AMAZON_ACCESS_KEY_ID;
    const key = process.env.AWS_SECRET_ACCESS_KEY || process.env.AMAZON_SECRET_ACCESS_KEY;
    if (!!id && !!key) {
        process.env.AWS_ACCESS_KEY_ID = id;
        process.env.AWS_SECRET_ACCESS_KEY = key;
        const sessionToken = process.env.AWS_SESSION_TOKEN ?? process.env.AMAZON_SESSION_TOKEN;
        if (sessionToken) {
            process.env.AWS_SESSION_TOKEN = sessionToken;
        }
        return true;
    }
    return false;
}
/**
 * The MetadataService class will attempt to fetch the instance identity document from
 * IMDSv2 first, and then will attempt v1 as a fallback.
 *
 * If this fails, we will use us-east-1 as the region so no error should be thrown.
 * @returns The region for the instance identity
 */
async function regionFromMetadataService() {
    (0, logging_1.debug)('Looking up AWS region in the EC2 Instance Metadata Service (IMDS).');
    try {
        const metadataService = new ec2_metadata_service_1.MetadataService({
            httpOptions: {
                timeout: 1000,
            },
        });
        await metadataService.fetchMetadataToken();
        const document = await metadataService.request('/latest/dynamic/instance-identity/document', {});
        return JSON.parse(document).region;
    }
    catch (e) {
        (0, logging_1.debug)(`Unable to retrieve AWS region from IMDS: ${e}`);
    }
}
/**
 * Ask user for MFA token for given serial
 *
 * Result is send to callback function for SDK to authorize the request
 */
async function tokenCodeFn(serialArn) {
    (0, logging_1.debug)('Require MFA token for serial ARN', serialArn);
    try {
        const token = await promptly.prompt(`MFA token for ${serialArn}: `, {
            trim: true,
            default: '',
        });
        (0, logging_1.debug)('Successfully got MFA token from user');
        return token;
    }
    catch (err) {
        (0, logging_1.debug)('Failed to get MFA token', err);
        const e = new Error(`Error fetching MFA token: ${err.message ?? err}`);
        e.name = 'SharedIniFileCredentialsProviderFailure';
        throw e;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXdzY2xpLWNvbXBhdGlibGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJhd3NjbGktY29tcGF0aWJsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSx3RUFBK0c7QUFDL0csd0VBQWdFO0FBRWhFLDJFQUF1RTtBQUV2RSxxQ0FBcUM7QUFDckMsNkNBQXlDO0FBQ3pDLHlEQUF5RDtBQUV6RCxpQ0FBd0M7QUFDeEMsMkNBQXNDO0FBRXRDLE1BQU0sMEJBQTBCLEdBQUcsS0FBSyxDQUFDO0FBQ3pDLE1BQU0sZUFBZSxHQUFHLE1BQU0sQ0FBQztBQUUvQjs7Ozs7OztHQU9HO0FBQ0gsTUFBYSxnQkFBZ0I7SUFDM0I7Ozs7T0FJRztJQUNJLE1BQU0sQ0FBQyxLQUFLLENBQUMsc0JBQXNCLENBQ3hDLFVBQWtDLEVBQUU7UUFFcEMsTUFBTSxZQUFZLEdBQUc7WUFDbkIsY0FBYyxFQUFFLGdCQUFnQixDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUM7WUFDM0UsZUFBZSxFQUFFLFNBQVM7WUFDMUIsTUFBTSxFQUFFLE9BQU8sQ0FBQyxNQUFNO1NBQ3ZCLENBQUM7UUFFRjs7Ozs7Ozs7V0FRRztRQUNILElBQUksT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ3BCLE9BQU8sSUFBQSxzQ0FBbUIsRUFBQyxJQUFBLDhCQUFPLEVBQUM7Z0JBQ2pDLE9BQU8sRUFBRSxPQUFPLENBQUMsT0FBTztnQkFDeEIsV0FBVyxFQUFFLElBQUk7Z0JBQ2pCLGVBQWUsRUFBRSxXQUFXO2dCQUM1QixZQUFZO2dCQUNaLE1BQU0sRUFBRSxPQUFPLENBQUMsTUFBTTthQUN2QixDQUFDLENBQUMsQ0FBQztRQUNOLENBQUM7UUFFRCxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLFdBQVcsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDO1FBRTlFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1dBc0JHO1FBQ0gsTUFBTSxp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TSxLQUFLLEdBQVcsTUFBTSxRQUFRLENBQUMsTUFBTSxDQUFDLGlCQUFpQixTQUFTLElBQUksRUFBRTtZQUMxRSxJQUFJLEVBQUUsSUFBSTtZQUNWLE9BQU8sRUFBRSxFQUFFO1NBQ1osQ0FBQyxDQUFDO1FBQ0gsSUFBQSxlQUFLLEVBQUMsc0NBQXNDLENBQUMsQ0FBQztRQUM5QyxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFBQyxPQUFPLEdBQVEsRUFBRSxDQUFDO1FBQ2xCLElBQUEsZUFBSyxFQUFDLHlCQUF5QixFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ3RDLE1BQU0sQ0FBQyxHQUFHLElBQUksS0FBSyxDQUFDLDZCQUE2QixHQUFHLENBQUMsT0FBTyxJQUFJLEdBQUcsRUFBRSxDQUFDLENBQUM7UUFDdkUsQ0FBQyxDQUFDLElBQUksR0FBRyx5Q0FBeUMsQ0FBQztRQUNuRCxNQUFNLENBQUMsQ0FBQztJQUNWLENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ3JlZGVudGlhbENoYWluLCBmcm9tRW52LCBmcm9tSW5pLCBmcm9tTm9kZVByb3ZpZGVyQ2hhaW4gfSBmcm9tICdAYXdzLXNkay9jcmVkZW50aWFsLXByb3ZpZGVycyc7XG5pbXBvcnQgeyBNZXRhZGF0YVNlcnZpY2UgfSBmcm9tICdAYXdzLXNkay9lYzItbWV0YWRhdGEtc2VydmljZSc7XG5pbXBvcnQgdHlwZSB7IE5vZGVIdHRwSGFuZGxlck9wdGlvbnMgfSBmcm9tICdAc21pdGh5L25vZGUtaHR0cC1oYW5kbGVyJztcbmltcG9ydCB7IGxvYWRTaGFyZWRDb25maWdGaWxlcyB9IGZyb20gJ0BzbWl0aHkvc2hhcmVkLWluaS1maWxlLWxvYWRlcic7XG5pbXBvcnQgeyBBd3NDcmVkZW50aWFsSWRlbnRpdHlQcm92aWRlciwgTG9nZ2VyIH0gZnJvbSAnQHNtaXRoeS90eXBlcyc7XG5pbXBvcnQgKiBhcyBwcm9tcHRseSBmcm9tICdwcm9tcHRseSc7XG5pbXBvcnQgeyBQcm94eUFnZW50IH0gZnJvbSAncHJveHktYWdlbnQnO1xuaW1wb3J0IHsgbWFrZUNhY2hpbmdQcm92aWRlciB9IGZyb20gJy4vcHJvdmlkZXItY2FjaGluZyc7XG5pbXBvcnQgdHlwZSB7IFNka0h0dHBPcHRpb25zIH0gZnJvbSAnLi9zZGstcHJvdmlkZXInO1xuaW1wb3J0IHsgcmVhZElmUG9zc2libGUgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi8uLi9sb2dnaW5nJztcblxuY29uc3QgREVGQVVMVF9DT05ORUNUSU9OX1RJTUVPVVQgPSAxMDAwMDtcbmNvbnN0IERFRkFVTFRfVElNRU9VVCA9IDMwMDAwMDtcblxuLyoqXG4gKiBCZWhhdmlvcnMgdG8gbWF0Y2ggQVdTIENMSVxuICpcbiAqIFNlZSB0aGVzZSBsaW5rczpcbiAqXG4gKiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vY2xpL2xhdGVzdC90b3BpYy9jb25maWctdmFycy5odG1sXG4gKiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vY2xpL2xhdGVzdC91c2VyZ3VpZGUvY2xpLWNvbmZpZ3VyZS1lbnZ2YXJzLmh0bWxcbiAqL1xuZXhwb3J0IGNsYXNzIEF3c0NsaUNvbXBhdGlibGUge1xuICAvKipcbiAgICogQnVpbGQgYW4gQVdTIENMSS1jb21wYXRpYmxlIGNyZWRlbnRpYWwgY2hhaW4gcHJvdmlkZXJcbiAgICpcbiAgICogVGhlIGNyZWRlbnRpYWwgY2hhaW4gcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiBpcyBhbHdheXMgY2FjaGluZy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgY3JlZGVudGlhbENoYWluQnVpbGRlcihcbiAgICBvcHRpb25zOiBDcmVkZW50aWFsQ2hhaW5PcHRpb25zID0ge30sXG4gICk6IFByb21pc2U8QXdzQ3JlZGVudGlhbElkZW50aXR5UHJvdmlkZXI+IHtcbiAgICBjb25zdCBjbGllbnRDb25maWcgPSB7XG4gICAgICByZXF1ZXN0SGFuZGxlcjogQXdzQ2xpQ29tcGF0aWJsZS5yZXF1ZXN0SGFuZGxlckJ1aWxkZXIob3B0aW9ucy5odHRwT3B0aW9ucyksXG4gICAgICBjdXN0b21Vc2VyQWdlbnQ6ICdhd3MtY2RrJyxcbiAgICAgIGxvZ2dlcjogb3B0aW9ucy5sb2dnZXIsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91cyBpbXBsZW1lbnRhdGlvbiBtYXRjaGVkIEFXUyBDTEkgYmVoYXZpb3I6XG4gICAgICpcbiAgICAgKiBJZiBhIHByb2ZpbGUgaXMgZXhwbGljaXRseSBzZXQgdXNpbmcgYC0tcHJvZmlsZWAsXG4gICAgICogd2UgdXNlIHRoYXQgdG8gdGhlIGV4Y2x1c2lvbiBvZiBldmVyeXRoaW5nIGVsc2UuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIGRvZXMgbm90IGFwcGx5IHRvIEFXU19QUk9GSUxFLFxuICAgICAqIGVudmlyb25tZW50IGNyZWRlbnRpYWxzIHN0aWxsIHRha2UgcHJlY2VkZW5jZSBvdmVyIEFXU19QUk9GSUxFXG4gICAgICovXG4gICAgaWYgKG9wdGlvbnMucHJvZmlsZSkge1xuICAgICAgcmV0dXJuIG1ha2VDYWNoaW5nUHJvdmlkZXIoZnJvbUluaSh7XG4gICAgICAgIHByb2ZpbGU6IG9wdGlvbnMucHJvZmlsZSxcbiAgICAgICAgaWdub3JlQ2FjaGU6IHRydWUsXG4gICAgICAgIG1mYUNvZGVQcm92aWRlcjogdG9rZW5Db2RlRm4sXG4gICAgICAgIGNsaWVudENvbmZpZyxcbiAgICAgICAgbG9nZ2VyOiBvcHRpb25zLmxvZ2dlcixcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBjb25zdCBlbnZQcm9maWxlID0gcHJvY2Vzcy5lbnYuQVdTX1BST0ZJTEUgfHwgcHJvY2Vzcy5lbnYuQVdTX0RFRkFVTFRfUFJPRklMRTtcblxuICAgIC8qKlxuICAgICAqIEVudiBBV1MgLSBFbnZpcm9ubWVudENyZWRlbnRpYWxzIHdpdGggc3RyaW5nIEFXU1xuICAgICAqIEVudiBBbWF6b24gLSBFbnZpcm9ubWVudENyZWRlbnRpYWxzIHdpdGggc3RyaW5nIEFNQVpPTlxuICAgICAqIFByb2ZpbGUgQ3JlZGVudGlhbHMgLSBQYXRjaGVkU2hhcmVkSW5pRmlsZUNyZWRlbnRpYWxzIHdpdGggaW1wbGljaXQgcHJvZmlsZSwgY3JlZGVudGlhbHMgZmlsZSwgaHR0cCBvcHRpb25zLCBhbmQgdG9rZW4gZm5cbiAgICAgKiAgICBTU08gd2l0aCBpbXBsaWNpdCBwcm9maWxlIG9ubHlcbiAgICAgKiAgICBTaGFyZWRJbmlGaWxlQ3JlZGVudGlhbHMgd2l0aCBpbXBsaWNpdCBwcm9maWxlIGFuZCBwcmVmZXJTdGF0aWNDcmVkZW50aWFscyB0cnVlIChwcm9maWxlIHdpdGggc291cmNlX3Byb2ZpbGUpXG4gICAgICogICAgU2hhcmVkIENyZWRlbnRpYWwgZmlsZSB0aGF0IHBvaW50cyB0byBFbnZpcm9ubWVudCBDcmVkZW50aWFscyB3aXRoIEFXUyBwcmVmaXhcbiAgICAgKiAgICBTaGFyZWQgQ3JlZGVudGlhbCBmaWxlIHRoYXQgcG9pbnRzIHRvIEVDMiBNZXRhZGF0YVxuICAgICAqICAgIFNoYXJlZCBDcmVkZW50aWFsIGZpbGUgdGhhdCBwb2ludHMgdG8gRUNTIENyZWRlbnRpYWxzXG4gICAgICogU1NPIENyZWRlbnRpYWxzIC0gU3NvQ3JlZGVudGlhbHMgd2l0aCBpbXBsaWNpdCBwcm9maWxlIGFuZCBodHRwIG9wdGlvbnNcbiAgICAgKiBQcm9jZXNzQ3JlZGVudGlhbHMgd2l0aCBpbXBsaWNpdCBwcm9maWxlXG4gICAgICogRUNTIENyZWRlbnRpYWxzIC0gRUNTQ3JlZGVudGlhbHMgd2l0aCBubyBpbnB1dCBPUiBXZWIgSWRlbnRpdHkgLSBUb2tlbkZpbGVXZWJJZGVudGl0eUNyZWRlbnRpYWxzIHdpdGggbm8gaW5wdXQgT1IgRUMyIE1ldGFkYXRhIC0gRUMyTWV0YWRhdGFDcmVkZW50aWFscyB3aXRoIG5vIGlucHV0XG4gICAgICpcbiAgICAgKiBUaGVzZSB0cmFuc2xhdGUgdG86XG4gICAgICogZnJvbUVudigpXG4gICAgICogZnJvbVNTTygpL2Zyb21JbmkoKVxuICAgICAqIGZyb21Qcm9jZXNzKClcbiAgICAgKiBmcm9tQ29udGFpbmVyTWV0YWRhdGEoKVxuICAgICAqIGZyb21Ub2tlbkZpbGUoKVxuICAgICAqIGZyb21JbnN0YW5jZU1ldGFkYXRhKClcbiAgICAgKlxuICAgICAqIFRoZSBOb2RlUHJvdmlkZXJDaGFpbiBpcyBhbHJlYWR5IGNhY2hlZC5cbiAgICAgKi9cbiAgICBjb25zdCBub2RlUHJvdmlkZXJDaGFpbiA9IGZyb21Ob2RlUHJvdmlkZXJDaGFpbih7XG4gICAgICBwcm9maWxlOiBlbnZQcm9maWxlLFxuICAgICAgY2xpZW50Q29uZmlnLFxuICAgICAgbG9nZ2VyOiBvcHRpb25zLmxvZ2dlcixcbiAgICAgIG1mYUNvZGVQcm92aWRlcjogdG9rZW5Db2RlRm4sXG4gICAgICBpZ25vcmVDYWNoZTogdHJ1ZSxcbiAgICB9KTtcblxuICAgIHJldHVybiBzaG91bGRQcmlvcml0aXplRW52KClcbiAgICAgID8gY3JlYXRlQ3JlZGVudGlhbENoYWluKGZyb21FbnYoKSwgbm9kZVByb3ZpZGVyQ2hhaW4pLmV4cGlyZUFmdGVyKDYwICogNjBfMDAwKVxuICAgICAgOiBub2RlUHJvdmlkZXJDaGFpbjtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgcmVxdWVzdEhhbmRsZXJCdWlsZGVyKG9wdGlvbnM6IFNka0h0dHBPcHRpb25zID0ge30pOiBOb2RlSHR0cEhhbmRsZXJPcHRpb25zIHtcbiAgICAvLyBGb3JjZSBpdCB0byB1c2UgdGhlIHByb3h5IHByb3ZpZGVkIHRocm91Z2ggdGhlIGNvbW1hbmQgbGluZS5cbiAgICAvLyBPdGhlcndpc2UsIGxldCB0aGUgUHJveHlBZ2VudCBhdXRvLWRldGVjdCB0aGUgcHJveHkgdXNpbmcgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICAgIGNvbnN0IGdldFByb3h5Rm9yVXJsID0gb3B0aW9ucy5wcm94eUFkZHJlc3MgIT0gbnVsbFxuICAgICAgPyAoKSA9PiBQcm9taXNlLnJlc29sdmUob3B0aW9ucy5wcm94eUFkZHJlc3MhKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCBhZ2VudCA9IG5ldyBQcm94eUFnZW50KHtcbiAgICAgIGNhOiB0cnlHZXRDQUNlcnQob3B0aW9ucy5jYUJ1bmRsZVBhdGgpLFxuICAgICAgZ2V0UHJveHlGb3JVcmw6IGdldFByb3h5Rm9yVXJsLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbm5lY3Rpb25UaW1lb3V0OiBERUZBVUxUX0NPTk5FQ1RJT05fVElNRU9VVCxcbiAgICAgIHJlcXVlc3RUaW1lb3V0OiBERUZBVUxUX1RJTUVPVVQsXG4gICAgICBodHRwc0FnZW50OiBhZ2VudCxcbiAgICAgIGh0dHBBZ2VudDogYWdlbnQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBnZXQgdGhlIHJlZ2lvbiBmcm9tIGEgbnVtYmVyIG9mIHNvdXJjZXMgYW5kIGZhbGxzIGJhY2sgdG8gdXMtZWFzdC0xIGlmIG5vIHJlZ2lvbiBjYW4gYmUgZm91bmQsXG4gICAqIGFzIGlzIGRvbmUgaW4gdGhlIEFXUyBDTEkuXG4gICAqXG4gICAqIFRoZSBvcmRlciBvZiBwcmlvcml0eSBpcyB0aGUgZm9sbG93aW5nOlxuICAgKlxuICAgKiAxLiBFbnZpcm9ubWVudCB2YXJpYWJsZXMgc3BlY2lmeWluZyByZWdpb24sIHdpdGggYm90aCBhbiBBV1MgcHJlZml4IGFuZCBBTUFaT04gcHJlZml4XG4gICAqICAgIHRvIG1haW50YWluIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBhbmQgd2l0aG91dCBgREVGQVVMVGAgaW4gdGhlIG5hbWUgYmVjYXVzZVxuICAgKiAgICBMYW1iZGEgYW5kIENvZGVCdWlsZCBzZXQgdGhlICRBV1NfUkVHSU9OIHZhcmlhYmxlLlxuICAgKiAyLiBSZWdpb25zIGxpc3RlZCBpbiB0aGUgU2hhcmVkIEluaSBGaWxlcyAtIEZpcnN0IGNoZWNraW5nIGZvciB0aGUgcHJvZmlsZSBwcm92aWRlZFxuICAgKiAgICBhbmQgdGhlbiBjaGVja2luZyBmb3IgdGhlIGRlZmF1bHQgcHJvZmlsZS5cbiAgICogMy4gSU1EUyBpbnN0YW5jZSBpZGVudGl0eSByZWdpb24gZnJvbSB0aGUgTWV0YWRhdGEgU2VydmljZS5cbiAgICogNC4gdXMtZWFzdC0xXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIHJlZ2lvbihtYXliZVByb2ZpbGU/OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IGRlZmF1bHRSZWdpb24gPSAndXMtZWFzdC0xJztcbiAgICBjb25zdCBwcm9maWxlID0gbWF5YmVQcm9maWxlIHx8IHByb2Nlc3MuZW52LkFXU19QUk9GSUxFIHx8IHByb2Nlc3MuZW52LkFXU19ERUZBVUxUX1BST0ZJTEUgfHwgJ2RlZmF1bHQnO1xuXG4gICAgY29uc3QgcmVnaW9uID1cbiAgICAgIHByb2Nlc3MuZW52LkFXU19SRUdJT04gfHxcbiAgICAgIHByb2Nlc3MuZW52LkFNQVpPTl9SRUdJT04gfHxcbiAgICAgIHByb2Nlc3MuZW52LkFXU19ERUZBVUxUX1JFR0lPTiB8fFxuICAgICAgcHJvY2Vzcy5lbnYuQU1BWk9OX0RFRkFVTFRfUkVHSU9OIHx8XG4gICAgICAoYXdhaXQgZ2V0UmVnaW9uRnJvbUluaShwcm9maWxlKSkgfHxcbiAgICAgIChhd2FpdCByZWdpb25Gcm9tTWV0YWRhdGFTZXJ2aWNlKCkpO1xuXG4gICAgaWYgKCFyZWdpb24pIHtcbiAgICAgIGNvbnN0IHVzZWRQcm9maWxlID0gIXByb2ZpbGUgPyAnJyA6IGAgKHByb2ZpbGU6IFwiJHtwcm9maWxlfVwiKWA7XG4gICAgICBkZWJ1ZyhcbiAgICAgICAgYFVuYWJsZSB0byBkZXRlcm1pbmUgQVdTIHJlZ2lvbiBmcm9tIGVudmlyb25tZW50IG9yIEFXUyBjb25maWd1cmF0aW9uJHt1c2VkUHJvZmlsZX0sIGRlZmF1bHRpbmcgdG8gJyR7ZGVmYXVsdFJlZ2lvbn0nYCxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZGVmYXVsdFJlZ2lvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnaW9uO1xuICB9XG59XG5cbi8qKlxuICogTG9va3MgdXAgdGhlIHJlZ2lvbiBvZiB0aGUgcHJvdmlkZWQgcHJvZmlsZS4gSWYgbm8gcmVnaW9uIGlzIHByZXNlbnQsXG4gKiBpdCB3aWxsIGF0dGVtcHQgdG8gbG9va3VwIHRoZSBkZWZhdWx0IHJlZ2lvbi5cbiAqIEBwYXJhbSBwcm9maWxlIFRoZSBwcm9maWxlIHRvIHVzZSB0byBsb29rdXAgdGhlIHJlZ2lvblxuICogQHJldHVybnMgVGhlIHJlZ2lvbiBmb3IgdGhlIHByb2ZpbGUgb3IgZGVmYXVsdCBwcm9maWxlLCBpZiBwcmVzZW50LiBPdGhlcndpc2UgcmV0dXJucyB1bmRlZmluZWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFJlZ2lvbkZyb21JbmkocHJvZmlsZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgY29uc3Qgc2hhcmVkRmlsZXMgPSBhd2FpdCBsb2FkU2hhcmVkQ29uZmlnRmlsZXMoeyBpZ25vcmVDYWNoZTogdHJ1ZSB9KTtcblxuICAvLyBQcmlvcml0eTpcbiAgLy9cbiAgLy8gY3JlZGVudGlhbHMgY29tZSBiZWZvcmUgY29uZmlnIGJlY2F1c2UgYXdzLWNsaSB2MSBiZWhhdmVzIGxpa2UgdGhhdC5cbiAgLy9cbiAgLy8gMS4gcHJvZmlsZS1yZWdpb24taW4tY3JlZGVudGlhbHNcbiAgLy8gMi4gcHJvZmlsZS1yZWdpb24taW4tY29uZmlnXG4gIC8vIDMuIGRlZmF1bHQtcmVnaW9uLWluLWNyZWRlbnRpYWxzXG4gIC8vIDQuIGRlZmF1bHQtcmVnaW9uLWluLWNvbmZpZ1xuXG4gIHJldHVybiBnZXRSZWdpb25Gcm9tSW5pRmlsZShwcm9maWxlLCBzaGFyZWRGaWxlcy5jcmVkZW50aWFsc0ZpbGUpXG4gICAgPz8gZ2V0UmVnaW9uRnJvbUluaUZpbGUocHJvZmlsZSwgc2hhcmVkRmlsZXMuY29uZmlnRmlsZSlcbiAgICA/PyBnZXRSZWdpb25Gcm9tSW5pRmlsZSgnZGVmYXVsdCcsIHNoYXJlZEZpbGVzLmNyZWRlbnRpYWxzRmlsZSlcbiAgICA/PyBnZXRSZWdpb25Gcm9tSW5pRmlsZSgnZGVmYXVsdCcsIHNoYXJlZEZpbGVzLmNvbmZpZ0ZpbGUpO1xuXG59XG5cbmZ1bmN0aW9uIGdldFJlZ2lvbkZyb21JbmlGaWxlKHByb2ZpbGU6IHN0cmluZywgZGF0YT86IGFueSkge1xuICByZXR1cm4gZGF0YT8uW3Byb2ZpbGVdPy5yZWdpb247XG59XG5cbmZ1bmN0aW9uIHRyeUdldENBQ2VydChidW5kbGVQYXRoPzogc3RyaW5nKSB7XG4gIGNvbnN0IHBhdGggPSBidW5kbGVQYXRoIHx8IGNhQnVuZGxlUGF0aEZyb21FbnZpcm9ubWVudCgpO1xuICBpZiAocGF0aCkge1xuICAgIGRlYnVnKCdVc2luZyBDQSBidW5kbGUgcGF0aDogJXMnLCBwYXRoKTtcbiAgICByZXR1cm4gcmVhZElmUG9zc2libGUocGF0aCk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBGaW5kIGFuZCByZXR1cm4gYSBDQSBjZXJ0aWZpY2F0ZSBidW5kbGUgcGF0aCB0byBiZSBwYXNzZWQgaW50byB0aGUgU0RLLlxuICovXG5mdW5jdGlvbiBjYUJ1bmRsZVBhdGhGcm9tRW52aXJvbm1lbnQoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHByb2Nlc3MuZW52LmF3c19jYV9idW5kbGUpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuYXdzX2NhX2J1bmRsZTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuQVdTX0NBX0JVTkRMRSkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5BV1NfQ0FfQlVORExFO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogV2UgdXNlZCB0byBzdXBwb3J0IGJvdGggQVdTIGFuZCBBTUFaT04gcHJlZml4ZXMgZm9yIHRoZXNlIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiBBZGRpbmcgdGhpcyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAqL1xuZnVuY3Rpb24gc2hvdWxkUHJpb3JpdGl6ZUVudigpIHtcbiAgY29uc3QgaWQgPSBwcm9jZXNzLmVudi5BV1NfQUNDRVNTX0tFWV9JRCB8fCBwcm9jZXNzLmVudi5BTUFaT05fQUNDRVNTX0tFWV9JRDtcbiAgY29uc3Qga2V5ID0gcHJvY2Vzcy5lbnYuQVdTX1NFQ1JFVF9BQ0NFU1NfS0VZIHx8IHByb2Nlc3MuZW52LkFNQVpPTl9TRUNSRVRfQUNDRVNTX0tFWTtcblxuICBpZiAoISFpZCAmJiAhIWtleSkge1xuICAgIHByb2Nlc3MuZW52LkFXU19BQ0NFU1NfS0VZX0lEID0gaWQ7XG4gICAgcHJvY2Vzcy5lbnYuQVdTX1NFQ1JFVF9BQ0NFU1NfS0VZID0ga2V5O1xuXG4gICAgY29uc3Qgc2Vzc2lvblRva2VuID0gcHJvY2Vzcy5lbnYuQVdTX1NFU1NJT05fVE9LRU4gPz8gcHJvY2Vzcy5lbnYuQU1BWk9OX1NFU1NJT05fVE9LRU47XG4gICAgaWYgKHNlc3Npb25Ub2tlbikge1xuICAgICAgcHJvY2Vzcy5lbnYuQVdTX1NFU1NJT05fVE9LRU4gPSBzZXNzaW9uVG9rZW47XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVGhlIE1ldGFkYXRhU2VydmljZSBjbGFzcyB3aWxsIGF0dGVtcHQgdG8gZmV0Y2ggdGhlIGluc3RhbmNlIGlkZW50aXR5IGRvY3VtZW50IGZyb21cbiAqIElNRFN2MiBmaXJzdCwgYW5kIHRoZW4gd2lsbCBhdHRlbXB0IHYxIGFzIGEgZmFsbGJhY2suXG4gKlxuICogSWYgdGhpcyBmYWlscywgd2Ugd2lsbCB1c2UgdXMtZWFzdC0xIGFzIHRoZSByZWdpb24gc28gbm8gZXJyb3Igc2hvdWxkIGJlIHRocm93bi5cbiAqIEByZXR1cm5zIFRoZSByZWdpb24gZm9yIHRoZSBpbnN0YW5jZSBpZGVudGl0eVxuICovXG5hc3luYyBmdW5jdGlvbiByZWdpb25Gcm9tTWV0YWRhdGFTZXJ2aWNlKCkge1xuICBkZWJ1ZygnTG9va2luZyB1cCBBV1MgcmVnaW9uIGluIHRoZSBFQzIgSW5zdGFuY2UgTWV0YWRhdGEgU2VydmljZSAoSU1EUykuJyk7XG4gIHRyeSB7XG4gICAgY29uc3QgbWV0YWRhdGFTZXJ2aWNlID0gbmV3IE1ldGFkYXRhU2VydmljZSh7XG4gICAgICBodHRwT3B0aW9uczoge1xuICAgICAgICB0aW1lb3V0OiAxMDAwLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGF3YWl0IG1ldGFkYXRhU2VydmljZS5mZXRjaE1ldGFkYXRhVG9rZW4oKTtcbiAgICBjb25zdCBkb2N1bWVudCA9IGF3YWl0IG1ldGFkYXRhU2VydmljZS5yZXF1ZXN0KCcvbGF0ZXN0L2R5bmFtaWMvaW5zdGFuY2UtaWRlbnRpdHkvZG9jdW1lbnQnLCB7fSk7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZG9jdW1lbnQpLnJlZ2lvbjtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlYnVnKGBVbmFibGUgdG8gcmV0cmlldmUgQVdTIHJlZ2lvbiBmcm9tIElNRFM6ICR7ZX1gKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENyZWRlbnRpYWxDaGFpbk9wdGlvbnMge1xuICByZWFkb25seSBwcm9maWxlPzogc3RyaW5nO1xuICByZWFkb25seSBodHRwT3B0aW9ucz86IFNka0h0dHBPcHRpb25zO1xuICByZWFkb25seSBsb2dnZXI/OiBMb2dnZXI7XG59XG5cbi8qKlxuICogQXNrIHVzZXIgZm9yIE1GQSB0b2tlbiBmb3IgZ2l2ZW4gc2VyaWFsXG4gKlxuICogUmVzdWx0IGlzIHNlbmQgdG8gY2FsbGJhY2sgZnVuY3Rpb24gZm9yIFNESyB0byBhdXRob3JpemUgdGhlIHJlcXVlc3RcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdG9rZW5Db2RlRm4oc2VyaWFsQXJuOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICBkZWJ1ZygnUmVxdWlyZSBNRkEgdG9rZW4gZm9yIHNlcmlhbCBBUk4nLCBzZXJpYWxBcm4pO1xuICB0cnkge1xuICAgIGNvbnN0IHRva2VuOiBzdHJpbmcgPSBhd2FpdCBwcm9tcHRseS5wcm9tcHQoYE1GQSB0b2tlbiBmb3IgJHtzZXJpYWxBcm59OiBgLCB7XG4gICAgICB0cmltOiB0cnVlLFxuICAgICAgZGVmYXVsdDogJycsXG4gICAgfSk7XG4gICAgZGVidWcoJ1N1Y2Nlc3NmdWxseSBnb3QgTUZBIHRva2VuIGZyb20gdXNlcicpO1xuICAgIHJldHVybiB0b2tlbjtcbiAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICBkZWJ1ZygnRmFpbGVkIHRvIGdldCBNRkEgdG9rZW4nLCBlcnIpO1xuICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IoYEVycm9yIGZldGNoaW5nIE1GQSB0b2tlbjogJHtlcnIubWVzc2FnZSA/PyBlcnJ9YCk7XG4gICAgZS5uYW1lID0gJ1NoYXJlZEluaUZpbGVDcmVkZW50aWFsc1Byb3ZpZGVyRmFpbHVyZSc7XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuIl19